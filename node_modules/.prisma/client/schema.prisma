datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
  engineType    = "binary"
}

model User {
  user_id                   Int                  @id @default(autoincrement())
  first_name                String
  last_name                 String
  email                     String               @unique
  phone_number              String               @unique
  profile_photo             String?
  valid_id                  String?
  user_location             String?
  created_at                DateTime             @default(now())
  is_verified               Boolean              @default(false)
  verification_status       String               @default("pending") // pending, approved, rejected
  rejection_reason          String?
  verification_submitted_at DateTime?
  verification_reviewed_at  DateTime?
  password                  String
  userName                  String               @unique
  is_activated              Boolean              @default(true)
  birthday                  DateTime?
  exact_location            String?
  user_reason               String?
  user_appointments         Appointment[]
  user_rating               Rating[]
  conversations             Conversation[]
  backjob_applications      BackjobApplication[] @relation("UserBackjobs")
}

model ServiceProviderDetails {
  provider_id               Int                  @id @default(autoincrement())
  provider_first_name       String
  provider_last_name        String
  provider_email            String               @unique
  provider_phone_number     String               @unique
  provider_profile_photo    String?
  provider_valid_id         String?
  provider_isVerified       Boolean              @default(false)
  verification_status       String               @default("pending") // pending, approved, rejected
  rejection_reason          String?
  verification_submitted_at DateTime?
  verification_reviewed_at  DateTime?
  created_at                DateTime             @default(now())
  provider_rating           Float                @default(0.0)
  provider_location         String?
  provider_uli              String               @unique
  provider_password         String
  provider_userName         String               @unique
  provider_isActivated      Boolean              @default(true)
  provider_birthday         DateTime?
  provider_exact_location   String?
  provider_reason           String?
  provider_appointments     Appointment[]
  provider_availability     Availability[]
  provider_certificates     Certificate[]
  provider_ratings          Rating[]
  provider_services         ServiceListing[]
  conversations             Conversation[]
  provider_professions      ProviderProfession[]
  backjob_applications      BackjobApplication[] @relation("ProviderBackjobs")
}

model Certificate {
  certificate_id        Int                    @id @default(autoincrement())
  certificate_name      String
  certificate_file_path String
  expiry_date           DateTime?
  provider_id           Int
  certificate_number    String                 @unique
  certificate_status    String                 @default("Pending")
  created_at            DateTime               @default(now())
  provider              ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
  certificate_reason    String?
  CoveredService        CoveredService[]
}

model ServiceListing {
  service_id              Int                    @id @default(autoincrement())
  service_title           String
  service_description     String
  service_startingprice   Float
  provider_id             Int
  servicelisting_isActive Boolean                @default(true)
  warranty                Int?
  service_photos          ServicePhoto[]
  appointments            Appointment[]
  serviceProvider         ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
  specific_services       SpecificService[]
}

model ServicePhoto {
  id         Int            @id @default(autoincrement())
  imageUrl   String // Cloudinary/S3 URL
  service    ServiceListing @relation(fields: [service_id], references: [service_id])
  service_id Int
  uploadedAt DateTime       @default(now())
}

model ServiceCategory {
  category_id       Int               @id @default(autoincrement())
  category_name     String
  specific_services SpecificService[]
}

model ProviderProfession {
  id          Int                    @id @default(autoincrement())
  provider_id Int
  profession  String
  experience  String // or Int for years
  provider    ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])

  @@unique([provider_id, profession]) // prevents duplicates of the same profession
}

model SpecificService {
  specific_service_id          Int              @id @default(autoincrement())
  specific_service_title       String
  specific_service_description String
  service_id                   Int
  category_id                  Int
  covered_by_certificates      CoveredService[]
  category                     ServiceCategory  @relation(fields: [category_id], references: [category_id])
  serviceListing               ServiceListing   @relation(fields: [service_id], references: [service_id])
}

model CoveredService {
  covered_service_id  Int             @id @default(autoincrement())
  specific_service_id Int
  certificate_id      Int
  certificate         Certificate     @relation(fields: [certificate_id], references: [certificate_id])
  specific_service    SpecificService @relation(fields: [specific_service_id], references: [specific_service_id])
}

model Availability {
  availability_id       Int                    @id @default(autoincrement())
  dayOfWeek             String
  startTime             String
  endTime               String
  provider_id           Int
  availability_isActive Boolean                @default(true)
  appointments          Appointment[]
  serviceProvider       ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
}

model Appointment {
  appointment_id          Int                    @id @default(autoincrement())
  customer_id             Int
  provider_id             Int
  appointment_status      String
  scheduled_date          DateTime
  repairDescription       String?
  created_at              DateTime               @default(now())
  final_price             Float?
  availability_id         Int
  service_id              Int
  cancellation_reason     String?
  // Warranty tracking
  warranty_days           Int? // Copied from ServiceListing.warranty at creation time
  finished_at             DateTime? // When provider marks service done
  completed_at            DateTime? // When customer marks service completed (or auto-completed)
  warranty_expires_at     DateTime? // finished_at + warranty_days
  // Warranty pause for backjobs
  warranty_paused_at      DateTime? // When warranty was paused (backjob applied)
  warranty_remaining_days Int? // Days remaining when paused
  availability            Availability           @relation(fields: [availability_id], references: [availability_id])
  customer                User                   @relation(fields: [customer_id], references: [user_id])
  serviceProvider         ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
  service                 ServiceListing         @relation(fields: [service_id], references: [service_id])
  appointment_rating      Rating[]
  backjob_applications    BackjobApplication[]
}

model Rating {
  id              Int                    @id @default(autoincrement())
  rating_value    Int
  rating_comment  String?
  rating_photo    String? // New field for review photo
  appointment_id  Int
  user_id         Int
  provider_id     Int
  rated_by        String // 'customer' or 'provider'
  created_at      DateTime               @default(now())
  appointment     Appointment            @relation(fields: [appointment_id], references: [appointment_id])
  serviceProvider ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
  user            User                   @relation(fields: [user_id], references: [user_id])
}

model OTPVerification {
  id         Int      @id @default(autoincrement())
  email      String
  otp        String
  expires_at DateTime
  created_at DateTime @default(now())
  verified   Boolean  @default(false)
}

model Admin {
  admin_id             Int       @id @default(autoincrement())
  admin_username       String    @unique
  admin_email          String    @unique
  admin_password       String
  admin_name           String
  admin_role           String    @default("admin")
  created_at           DateTime  @default(now())
  last_login           DateTime?
  is_active            Boolean   @default(true)
  must_change_password Boolean   @default(true)
}

model Conversation {
  conversation_id  Int                    @id @default(autoincrement())
  customer_id      Int
  provider_id      Int
  status           String                 @default("active") // active, archived, closed
  warranty_expires DateTime? // When this conversation should close due to warranty expiry
  last_message_at  DateTime?
  created_at       DateTime               @default(now())
  updated_at       DateTime               @updatedAt
  customer         User                   @relation(fields: [customer_id], references: [user_id])
  provider         ServiceProviderDetails @relation(fields: [provider_id], references: [provider_id])
  messages         Message[]

  @@unique([customer_id, provider_id]) // Only one active conversation per customer-provider pair
}

model Message {
  message_id      Int          @id @default(autoincrement())
  conversation_id Int
  sender_id       Int
  sender_type     String // 'customer' or 'provider'
  message_type    String       @default("text") // text, image, file, location
  content         String
  attachment_url  String?
  is_read         Boolean      @default(false)
  is_edited       Boolean      @default(false)
  edited_at       DateTime?
  replied_to_id   Int? // For reply functionality
  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt
  conversation    Conversation @relation(fields: [conversation_id], references: [conversation_id])
  replied_to      Message?     @relation("MessageReplies", fields: [replied_to_id], references: [message_id])
  replies         Message[]    @relation("MessageReplies")
}

// Backjob application raised during warranty period for an appointment
model BackjobApplication {
  backjob_id                   Int      @id @default(autoincrement())
  appointment_id               Int
  customer_id                  Int
  provider_id                  Int
  status                       String   @default("pending") // pending, approved, disputed, cancelled-by-admin, cancelled-by-user, cancelled-by-customer, rescheduled
  reason                       String
  evidence                     Json?
  provider_dispute_reason      String?
  provider_dispute_evidence    Json?
  customer_cancellation_reason String?
  admin_notes                  String?
  created_at                   DateTime @default(now())
  updated_at                   DateTime @updatedAt

  appointment Appointment            @relation(fields: [appointment_id], references: [appointment_id])
  customer    User                   @relation("UserBackjobs", fields: [customer_id], references: [user_id])
  provider    ServiceProviderDetails @relation("ProviderBackjobs", fields: [provider_id], references: [provider_id])

  @@index([appointment_id])
}
